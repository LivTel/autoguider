/* pco_command.cpp
** Autoguider PCO CMOS library
*/
/**
 * Command wrapper around the PCO SDK library.
 * @author Chris Mottram
 * @version $Id$
 */
/**
 * This hash define is needed before including source files give us POSIX.4/IEEE1003.1b-1993 prototypes.
 */
#define _POSIX_SOURCE 1
/**
 * This hash define is needed before including source files give us POSIX.4/IEEE1003.1b-1993 prototypes.
 */
#define _POSIX_C_SOURCE 199309L

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdarg.h>
#include <unistd.h>
#include "log_udp.h"
#include "VersionNo.h"
#include "Cpco_com.h"
#include "Cpco_grab_usb.h"
/*
 *  PCO_errt_w.h produces loads of -Wwrite-strings warnings when compiled, so turn off this warning for
 * this source file.
 */
#pragma GCC diagnostic ignored "-Wwrite-strings"
/**
 * Define PCO_ERRT_H_CREATE_OBJECT before including PCO_errt_w.h to enable the PCO_GetErrorText
 * function to be defined.
 */
#define PCO_ERRT_H_CREATE_OBJECT
/**
 * It is required by PCO_errt_w.h to define a sprintf_s function. PCO_errt_w.h defines one in the header
 * file for Microsoft C, here we declare sprintf_s as snprintf which should work for Linux.
 */
#define sprintf_s snprintf
#include "PCO_errt_w.h"
#include "ccd_general.h"
#include "pco_command.h"


/* check CCD_COMMAND_SETUP_FLAG enums match PCO_EDGE_SETUP #defines.
** We create our own enum so we don't have to include PCO SDK headers outside pco_command.cpp, for better
** code separation from the SDK */
/* THESE TESTS DON'T WORK, probably because one in an enumeration and one is an int.
#if CCD_COMMAND_SETUP_FLAG_ROLLING_SHUTTER != PCO_EDGE_SETUP_ROLLING_SHUTTER
#error "CCD_COMMAND_SETUP_FLAG_ROLLING_SHUTTER does not match PCO_EDGE_SETUP_ROLLING_SHUTTER declaration"
#endif
#if CCD_COMMAND_SETUP_FLAG_GLOBAL_SHUTTER != PCO_EDGE_SETUP_GLOBAL_SHUTTER
#error "CCD_COMMAND_SETUP_FLAG_GLOBAL_SHUTTER does not match PCO_EDGE_SETUP_GLOBAL_SHUTTER declaration"
#endif
#if CCD_COMMAND_SETUP_FLAG_GLOBAL_RESET != PCO_EDGE_SETUP_GLOBAL_RESET
#error "CCD_COMMAND_SETUP_FLAG_GLOBAL_RESET does not match PCO_EDGE_SETUP_GLOBAL_RESET declaration"
#endif
*/

/* data types */
/**
 * Data type holding local data to pco_command. This consists of the following:
 * <dl>
 * <dt>Camera</dt> <dd>The instance of CPco_com used to communicate with the PCO camera. </dd>
 * <dt>Grabber</dt> <dd>The instance of CPco_grab_usb used to grab images from the PCO camera. </dd>
 * <dt>PCO_Logger</dt> <dd>The instance of CPco_Log used to receive logging from the PCO library.</dd>
 * <dt>Camera_Board</dt> <dd>The board number passed to Open_Cam.</dd>
 * <dt>Grabber_Timeout</dt> <dd>The timeout for grabbing images, in milliseconds.</dd>
 * <dt>Description</dt> <dd>The camera description returned from PCO_GetCameraDescriptor. 
 *                      This is of type SC2_Camera_Description_Response (not PCO_Description as suggested in the SDK manual),
 *                      and is defined in: pco_camera_1_1_19/pco_common/pco_include/sc2_telegram.h</dd>
 * </dl>
 */
struct Command_Struct
{
	CPco_com *Camera;
	CPco_grab_usb* Grabber;
	CPco_Log* PCO_Logger;
	int Camera_Board;
	int Grabber_Timeout;
	SC2_Camera_Description_Response Description;
};

/* internal variables */
/**
 * Revision Control System identifier.
 */
static char rcsid[] = "$Id$";
/**
 * The instance of Command_Struct that contains local data for this module. This is initialised as follows:
 * <dl>
 * <dt>Camera</dt> <dd>NULL</dd>
 * <dt>Grabber</dt> <dd>NULL</dd>
 * <dt>PCO_Logger</dt> <dd>NULL</dd>
 * <dt>Camera_Board</dt> <dd>0</dd>
 * <dt>Grabber_Timeout</dt> <dd>40000</dd> (The PCO Edge's maximum exposure length is 20s).
 * <dt>Description</dt> <dd>{}</dd>
 * </dl>
 * @see #Command_Struct
 */
static struct Command_Struct Command_Data = 
{
	NULL,NULL,NULL,0,40000,
};

/**
 * A buffer to store the error string generated by a call to Command_PCO_Get_Error_Text.
 * @see #CCD_GENERAL_ERROR_STRING_LENGTH
 */
static char Command_PCO_Error_String[CCD_GENERAL_ERROR_STRING_LENGTH] = "";

/* internal functions */
static char *Command_PCO_Get_Error_Text(DWORD pco_err);
static int Command_BCD_To_Decimal(unsigned char x);

/* --------------------------------------------------------
** External Functions
** -------------------------------------------------------- */
/**
 * Initialise the PCO library Camera reference. 
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 */
int PCO_Command_Initialise_Camera(void)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Initialise_Camera",LOG_VERBOSITY_TERSE,NULL,"Started.");
#endif
	CCD_General_Error_Number = 0;
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Initialise_Camera",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"Creating CPco_com_usb instance.");
#endif
	Command_Data.Camera = new CPco_com_usb();
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1100;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Initialise_Camera:Creating CPco_com_usb instance failed.");
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Initialise_Camera",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"Creating CPco_Log instance.");
#endif 
	Command_Data.PCO_Logger = new CPco_Log("pco_camera_grab.log");
	if(Command_Data.PCO_Logger == NULL)
	{
		CCD_General_Error_Number =1101;
		sprintf(CCD_General_Error_String,"PCO_Command_Initialise_Camera:Creating CPco_Log instance failed.");
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Initialise_Camera",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"Initialising CPco_Log instance.");
#endif
 	Command_Data.PCO_Logger->set_logbits(0x3);
	Command_Data.Camera->SetLog(Command_Data.PCO_Logger);
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Initialise_Camera",LOG_VERBOSITY_TERSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Finalise (finish using) the PCO Camera object. 
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 */
int PCO_Command_Finalise_Camera(void)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Finalise",LOG_VERBOSITY_TERSE,NULL,"Started.");
#endif
	/* camera object */
	if(Command_Data.Camera != NULL)
	{
#ifdef PCO_DEBUG
		CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Finalise",LOG_VERBOSITY_VERY_VERBOSE,NULL,
				"Deleting Camera object.");
#endif
		delete Command_Data.Camera;
	}
	Command_Data.Camera = NULL;
	Command_Data.Grabber = NULL;
	/* logger object */
	if(Command_Data.PCO_Logger != NULL)
	{
#ifdef PCO_DEBUG
		CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Finalise",LOG_VERBOSITY_VERY_VERBOSE,NULL,
				"Deleting PCO_Logger object");
#endif
		delete Command_Data.PCO_Logger;
	}
	Command_Data.PCO_Logger = NULL;
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Finalise",LOG_VERBOSITY_TERSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Open a connection to the PCO camera and get a camera handle.
 * <ul>
 * <li>We check the Camera CPco_com_usb instance has been created.
 * <li>We set Command_Data.Camera_Board to the board parameter.
 * <li>We call the Camera's Open_Cam method with the board parameter to open a connection to the board.
 * <li>We get the camera's description by calling PCO_GetCameraDescriptor and store it in Command_Data.Description.
 * </ul>
 * @param board Which camera to connect to.
 * @return The routine returns TRUE on success and FALSE if it fails.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_GENERAL_ONE_SECOND_MS
 * @see ../../cdocs/ccd_general.html#CCD_GENERAL_ONE_MILLISECOND_NS
 * @see ../../cdocs/ccd_general.html#CCD_GENERAL_ONE_SECOND_NS
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Open(int board)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Open",LOG_VERBOSITY_TERSE,NULL,
			       "Started for board %d.",board);
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1102;
		sprintf(CCD_General_Error_String,"PCO_Command_Open:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	Command_Data.Camera_Board = board;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Open",LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "Calling Open_Cam(%d).",Command_Data.Camera_Board);
#endif
	pco_err = Command_Data.Camera->Open_Cam(Command_Data.Camera_Board);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1103;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Open:Camera Open_Cam(board=%d) failed with PCO error code 0x%x (%s).",
			Command_Data.Camera_Board,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Open",LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "Getting camera description.");
#endif
	pco_err = Command_Data.Camera->PCO_GetCameraDescriptor(&(Command_Data.Description));
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1104;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Open:Camera PCO_GetCameraDescriptor failed with PCO error code 0x%x (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Open",LOG_VERBOSITY_TERSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Close an open connection to the camera.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Close_Camera(void)
{
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Close_Camera",LOG_VERBOSITY_TERSE,NULL,"Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1105;
		sprintf(CCD_General_Error_String,"PCO_Command_Close_Camera:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	Command_Data.Camera->Close_Cam();
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Close_Camera",LOG_VERBOSITY_TERSE,NULL,"Finished.");	
#endif
	return TRUE;
}

/**
 * Routine to initialise the PCO Grabber object reference, which handles the downloading of image data.
 * This needs to be initialised after the PCO camera object has been initialised (PCO_Command_Initialise_Camera)
 *  and opened  (PCO_Command_Open).
 * <ul>
 * <li>We construct an instance of CPco_grab_usb attached to the opened camera and assign it to Command_Data.Grabber.
 * <li>We set the Grabber's log instance to Command_Data.PCO_Logger.
 * <li>We open a connection to the grabber by calling the Grabber's Open_Grabber method with the board parameter.
 * <li>We set the Grabber's timeout to Command_Data.Grabber_Timeout.
 * </ul>
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #PCO_Command_Initialise_Camera
 * @see #PCO_Command_Open
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Initialise_Grabber(void)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Initialise_Grabber",LOG_VERBOSITY_TERSE,NULL,"Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1106;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Initialise_Grabber:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	/* create grabber for opened camera */
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Initialise_Grabber",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"Creating Grabber for camera.");
#endif
	Command_Data.Grabber = new CPco_grab_usb((CPco_com_usb*)(Command_Data.Camera));
	if(Command_Data.Grabber == NULL)
	{
		CCD_General_Error_Number = 1107;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Initialise_Grabber:Creating CPco_grab_usb instance failed.");
		return FALSE;
	}
	Command_Data.Grabber->SetLog(Command_Data.PCO_Logger);
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Initialise_Grabber",LOG_VERBOSITY_INTERMEDIATE,
			       NULL,"Opening Grabber with board ID %d.",Command_Data.Camera_Board);
#endif
	pco_err = Command_Data.Grabber->Open_Grabber(Command_Data.Camera_Board);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1108;
		sprintf(CCD_General_Error_String,
		 "PCO_Command_Initialise_Grabber:Grabber Open_Grabber(board=%d) failed with PCO error code 0x%x (%s).",
			Command_Data.Camera_Board,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	Command_Data.Grabber->Set_Grabber_Timeout(Command_Data.Grabber_Timeout);
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Initialise_Grabber",LOG_VERBOSITY_TERSE,NULL,
			       "Finished.");
#endif
	return TRUE;
}

/**
 * Finalise (finish using) the PCO Grabber object. 
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 */
int PCO_Command_Finalise_Grabber(void)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Finalise_Grabber",LOG_VERBOSITY_TERSE,NULL,"Started.");
#endif
	/* grabber object */
	if(Command_Data.Grabber != NULL)
	{
#ifdef PCO_DEBUG
		CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Finalise_Grabber",LOG_VERBOSITY_VERY_VERBOSE,NULL,
				"Deleting Grabber object.");
#endif
		delete Command_Data.Grabber;
	}
	return TRUE;
}

/**
 * Close an open connection to the grabber.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Close_Grabber(void)
{
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Close_Grabber",LOG_VERBOSITY_TERSE,NULL,"Started.");
#endif
	if(Command_Data.Grabber == NULL)
	{
		CCD_General_Error_Number = 1210;
		sprintf(CCD_General_Error_String,"PCO_Command_CloseGrabber:Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	Command_Data.Grabber->Close_Grabber();
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Close_Grabber",LOG_VERBOSITY_TERSE,NULL,"Finished.");	
#endif
	return TRUE;
}

/**
 * Setup the camera. This changes some settings (notably shutter readout mode) which then requires a camera reboot
 * (and associated re-connect/open) to cause the camera head to pick up the new settings.
 * @param setup_flag The flag to setup. These are currently the shutter mode, set as follows:
 *        <ul>
 *        <li>0x00000001 = PCO_COMMAND_SETUP_FLAG_ROLLING_SHUTTER = PCO_EDGE_SETUP_ROLLING_SHUTTER = Rolling Shutter
 *        <li>0x00000002 = PCO_COMMAND_SETUP_FLAG_GLOBAL_SHUTTER  = PCO_EDGE_SETUP_GLOBAL_SHUTTER  = Global Shutter
 *        <li>0x00000004 = PCO_COMMAND_SETUP_FLAG_GLOBAL_RESET    = PCO_EDGE_SETUP_GLOBAL_RESET    = Global Reset 
 *        </ul>
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #PCO_COMMAND_SETUP_FLAG
 * @see #Command_PCO_Get_Error_Text
 * @see #Command_Data
 * @see #PCO_Command_Reboot_Camera
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Camera_Setup(enum PCO_COMMAND_SETUP_FLAG setup_flag)
{
	DWORD setup_flag_dword;
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Camera_Setup",LOG_VERBOSITY_VERBOSE,NULL,
			       "Started with setup flag 0x%x.",setup_flag);
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1109;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Camera_Setup:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	/* To set the current shutter mode input index setup_id must be set to 0. 
	** The new shutter mode should be set in setup_flag[0]. */
	setup_flag_dword = setup_flag;
	pco_err = Command_Data.Camera->PCO_SetCameraSetup(0,&setup_flag_dword,1);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1110;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Camera_Setup:"
			"Camera PCO_SetCameraSetup(0,0x%x,1) failed with PCO error code 0x%x (%s).",setup_flag_dword,
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Camera_Setup",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}
	
/**
 * This function reboots the PCO camera head. The function returns as soon as the reboot process has started. 
 * After calling this function the camera handle should be closed using PCO_Command_Close. 
 * The reboot can take 6-10 seconds.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_PCO_Get_Error_Text
 * @see #Command_Data
 * @see #PCO_Command_Close
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Reboot_Camera(void)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Reboot_Camera",LOG_VERBOSITY_VERBOSE,NULL,"Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1111;
		sprintf(CCD_General_Error_String,"PCO_Command_Reboot_Camera:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_RebootCamera();
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1112;
		sprintf(CCD_General_Error_String,"PCO_Command_Reboot_Camera:"
			"Camera PCO_RebootCamera failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Reboot_Camera",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Prepare the camera to start taking data. All previous settings are validated and the internal settings of the camera
 * updated.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_PCO_Get_Error_Text
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Arm_Camera(void)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Arm_Camera",LOG_VERBOSITY_VERBOSE,NULL,"Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1113;
		sprintf(CCD_General_Error_String,"PCO_Command_Arm_Camera:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_ArmCamera();
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1114;
		sprintf(CCD_General_Error_String,"PCO_Command_Arm_Camera:"
			"Camera PCO_ArmCamera failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Arm_Camera",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Prepare the camera to start taking data. All previous settings are validated and the internal settings of the camera
 * updated.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Grabber_Post_Arm(void)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Grabber_Post_Arm",LOG_VERBOSITY_VERBOSE,NULL,"Started.");
#endif
	if(Command_Data.Grabber == NULL)
	{
		CCD_General_Error_Number = 1115;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Grabber_Post_Arm:Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Grabber->PostArm();
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1116;
		sprintf(CCD_General_Error_String,"PCO_Command_Grabber_Post_Arm:"
			"Grabber PostArm failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Grabber_Post_Arm",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Set the camera's time to the current time.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Camera_To_Current_Time(void)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Camera_To_Current_Time",LOG_VERBOSITY_VERY_VERBOSE,
			NULL,"Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1117;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Camera_To_Current_Time:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetCameraToCurrentTime();
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1118;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Camera_To_Current_Time:"
			"Camera PCO_SetCameraToCurrentTime failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Camera_To_Current_Time",LOG_VERBOSITY_VERY_VERBOSE,
			NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Set the camera's recording state to either TRUE (1) or FALSE (0). This allows the camera to start
 * collecting data (exposures).
 * @param rec_state An integer/boolean, set to TRUE (1) to start recording data and FALSE (0) to stop recording data.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Recording_State(int rec_state)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Recording_State",LOG_VERBOSITY_INTERMEDIATE,
			       NULL,"PCO_Command_Set_Recording_State(%d): Started.",rec_state);
#endif
	if(!CCD_GENERAL_IS_BOOLEAN(rec_state))
	{
		CCD_General_Error_Number = 1119;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Recording_State:Illegal value for rec_state parameter (%d).",rec_state);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1120;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Recording_State:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetRecordingState(rec_state);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1121;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Recording_State:"
			"Camera PCO_SetRecordingState(%d) failed with PCO error code 0x%x (%s).",
			rec_state,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Recording_State",LOG_VERBOSITY_VERY_VERBOSE,NULL,
			"Finished.");
#endif
	return TRUE;
}

/**
 * Reset the cameras settings to a known (default) state.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Reset_Settings(void)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Reset_Settings",LOG_VERBOSITY_VERBOSE,NULL,"Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1122;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Reset_Settings:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_ResetSettingsToDefault();
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1123;
		sprintf(CCD_General_Error_String,"PCO_Command_Reset_Settings:"
			"Camera PCO_ResetSettingsToDefault failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Reset_Settings",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Set how the camera records timestamps. 
 * @param mode An PCO_COMMAND_TIMESTAMP_MODE enum: 0x0 (off), 0x1 (binary), 0x2 (binary+ASCII), 0x3 (ASCII).
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #PCO_COMMAND_TIMESTAMP_MODE
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Timestamp_Mode(enum PCO_COMMAND_TIMESTAMP_MODE mode)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Timestamp_Mode",LOG_VERBOSITY_VERBOSE,NULL,
			       "PCO_Command_Set_Timestamp_Mode(%d): Started.",mode);
#endif
	if((mode < 0)||(mode > 3))
	{
		CCD_General_Error_Number = 1124;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Timestamp_Mode:Illegal value for mode parameter (%d).",mode);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1125;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Timestamp_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetTimestampMode(mode);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1126;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Timestamp_Mode:"
			"Camera PCO_SetTimestampMode(%d) failed with PCO error code 0x%x (%s).",
			mode,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Timestamp_Mode",LOG_VERBOSITY_VERBOSE,NULL,
			"Finished.");
#endif
	return TRUE;
}

/**
 * Set the units used for delays and exposures.
 * @param delay_timebase A PCO_COMMAND_TIMEBASE enumeration , used to set the units used for delays.
 * @param exposure_timebase A PCO_COMMAND_TIMEBASE enumeration, used to set the units used for exposures.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #PCO_COMMAND_TIMEBASE
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Timebase(enum PCO_COMMAND_TIMEBASE delay_timebase,enum PCO_COMMAND_TIMEBASE exposure_timebase)
{
	WORD exp_timebase,del_timebase;
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Timebase",LOG_VERBOSITY_VERBOSE,NULL,
			       "PCO_Command_Set_Timebase(delay=%d,exposure=%d): Started.",
			       delay_timebase,exposure_timebase);
#endif
	if((delay_timebase < 0)||(delay_timebase > 2))
	{
		CCD_General_Error_Number = 1127;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Timebase:Illegal value for delay_timebase parameter (%d).",delay_timebase);
		return FALSE;
	}
	if((exposure_timebase < 0)||(exposure_timebase > 2))
	{
		CCD_General_Error_Number = 1128;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Timebase:Illegal value for exposure_timebase parameter (%d).",
			exposure_timebase);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1129;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Timebase:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	del_timebase = delay_timebase;
	exp_timebase = exposure_timebase;
	pco_err = Command_Data.Camera->PCO_SetTimebase(del_timebase,exp_timebase);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1130;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Timebase:"
			"Camera PCO_SetTimebase(%d,%d) failed with PCO error code 0x%x (%s).",
			del_timebase,exp_timebase,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Timebase",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Set the delay and exposure time.
 * @param delay_time An integer, used to set the delay, in units previously specified by PCO_Command_Set_Timebase.
 * @param exposure_time An integer, used to set the exposure length, 
 *        in units previously specified by PCO_Command_Set_Timebase.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #PCO_Command_Set_Timebase
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Delay_Exposure_Time(int delay_time,int exposure_time)
{
	DWORD exp_time_dw,delay_time_dw;
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Delay_Exposure_Time",LOG_VERBOSITY_INTERMEDIATE,
			       NULL,"PCO_Command_Set_Delay_Exposure_Time(delay=%d,exposure=%d): Started.",
			       delay_time,exposure_time);
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1131;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Delay_Exposure_Time:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	delay_time_dw = delay_time;
	exp_time_dw = exposure_time;
	pco_err = Command_Data.Camera->PCO_SetDelayExposure(delay_time_dw,exp_time_dw);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1132;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Delay_Exposure_Time:"
			"Camera PCO_SetDelayExposure(%d,%d) failed with PCO error code 0x%x (%s).",
			delay_time_dw,exp_time_dw,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Delay_Exposure_Time",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"PCO_Command_Set_Delay_Exposure_Time: Finished.");
#endif
	return TRUE;
}

/**
 * Set the number of analogue to digital converters used.
 * @param num_adcs An integer: either 0x1 or 0x2, the number of ADCs to use. 2 is faster, 1 is more linear.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_ADC_Operation(int num_adcs)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_ADC_Operation",LOG_VERBOSITY_VERBOSE,NULL,
			       "PCO_Command_Set_ADC_Operation(%d): Started.",num_adcs);
#endif
	if((num_adcs < 1)||(num_adcs > 2))
	{
		CCD_General_Error_Number = 1133;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_ADC_Operation:Illegal value for num_adcs parameter (%d).",num_adcs);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1134;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_ADC_Operation:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetADCOperation(num_adcs);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1135;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_ADC_Operation:"
			"Camera PCO_SetADCOperation(%d) failed with PCO error code 0x%x (%s).",
			num_adcs,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_ADC_Operation",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Set the bit alignment used for the output image data.
 * @param bit_alignment An integer: 0x0 (MSB) or 0x1 (LSB).
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Bit_Alignment(int bit_alignment)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Bit_Alignment",LOG_VERBOSITY_VERBOSE,NULL,
			       "PCO_Command_Set_Bit_Alignment(%d): Started.",bit_alignment);
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1136;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Bit_Alignment:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetBitAlignment(bit_alignment);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1137;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Bit_Alignment:"
			"Camera PCO_SetBitAlignment(%d) failed with PCO error code 0x%x (%s).",
			bit_alignment,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Bit_Alignment",LOG_VERBOSITY_VERBOSE,NULL,
			"PCO_Command_Set_Bit_Alignment: Finished.");
#endif
	return TRUE;
}

/**
 * Set what image corrects the camera performs.
 * @param mode An integer: 0x0000 (off), 0x0001 (noise filter on), 0x0101 (noise filter on + hot pixel correction).
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Noise_Filter_Mode(int mode)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Noise_Filter_Mode",LOG_VERBOSITY_VERBOSE,NULL,
			       "PCO_Command_Set_Noise_Filter_Mode(%d): Started.",mode);
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1138;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Noise_Filter_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetNoiseFilterMode(mode);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1139;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Noise_Filter_Mode:"
			"Camera PCO_SetNoiseFilterMode(%d) failed with PCO error code 0x%x (%s).",mode,pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Noise_Filter_Mode",LOG_VERBOSITY_VERBOSE,NULL,
			"Finished.");
#endif
	return TRUE;
}

/**
 * Set how camera exposures are triggered
 * @param mode An enum of type PCO_COMMAND_TRIGGER_MODE. Used to select external or internal trigger modes.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #PCO_COMMAND_TRIGGER_MODE
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Trigger_Mode(enum PCO_COMMAND_TRIGGER_MODE mode)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Trigger_Mode",LOG_VERBOSITY_VERBOSE,NULL,
			       "CCD_Command_Set_Trigger_Mode(%d): Started.",mode);
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1140;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Trigger_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetTriggerMode(mode);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1141;
		sprintf(CCD_General_Error_String,"CCD_Command_Set_Trigger_Mode:"
			"Camera PCO_SetTriggerMode(%d) failed with PCO error code 0x%x (%s).",mode,pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Trigger_Mode",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif	
	return TRUE;
}

/**
 * Set the camera binning.
 * @param bin_x An integer, the horizontal binning.
 * @param bin_y An integer, the vertical binning.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Binning(int bin_x,int bin_y)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Binning",LOG_VERBOSITY_VERBOSE,NULL,
			       "PCO_Command_Set_Binning(%d,%d): Started.",bin_x,bin_y);
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1142;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Binning:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetBinning(bin_x,bin_y);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1143;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Binning:"
			"Camera PCO_SetBinning(%d,%d) failed with PCO error code 0x%x (%s).",bin_x,bin_y,pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Binning",LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Set the current 'region of interest'. This is the area of the detector
 * to read out, in binned pixels.
 * @param start_x An integer containing the first binned pixel in x on the detector to read out.
 * @param start_y An integer containing the first binned pixel in y on the detector to read out.
 * @param end_x An integer containing the last binned pixel in x on the detector to read out.
 * @param end_y An integer containing the last binned pixel in y on the detector to read out.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_ROI(int start_x,int start_y,int end_x,int end_y)
{
	DWORD pco_err;
	WORD start_x_w,start_y_w,end_x_w,end_y_w;
	
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_ROI",LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Set_ROI(%d,%d,%d,%d): Started.",
			       start_x,start_y,end_x,end_y);
#endif
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1144;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_ROI:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	start_x_w = start_x;
	start_y_w = start_y;
	end_x_w = end_x;
	end_y_w = end_y;
	pco_err = Command_Data.Camera->PCO_SetROI(start_x_w,start_y_w,end_x_w,end_y_w);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1145;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_ROI:PCO_SetROI(%d,%d,%d,%d) failed(0x%x) (%s).",
			start_x_w,start_y_w,end_x_w,end_y_w,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_ROI",LOG_VERBOSITY_INTERMEDIATE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Set the temperature the camera head will try and attain.
 * @param temperature The temperature to try and cool the sensor to, in degrees centigrade.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Set_Cooling_Setpoint_Temperature(int temperature)
{
	DWORD pco_err;
	SHORT temperature_s;
	
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Set_Cooling_Setpoint_Temperature",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "CCD_Command_Set_Cooling_Setpoint_Temperature(%d): Started.",temperature);
#endif
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1146;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Set_Cooling_Setpoint_Temperature:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	temperature_s = temperature;
	pco_err = Command_Data.Camera->PCO_SetCoolingSetpointTemperature(temperature_s);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1147;
		sprintf(CCD_General_Error_String,"PCO_Command_Set_Cooling_Setpoint_Temperature:"
			"PCO_SetCoolingSetpointTemperature(%d) failed(0x%x) (%s).",
			temperature_s,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Set_Cooling_Setpoint_Temperature",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Finished.");
#endif
	return TRUE;
}

/**
 * Routine to return the actual image size the cameras will return, after a PCO_Command_Set_ROI / 
 * PCO_Command_Arm_Camera / PCO_Command_Grabber_Post_Arm call sequence.
 * @param w The address of an integer, on successful return filled in with the width of the image 
 *          returned by the camera.
 * @param h The address of an integer, on successful return filled in with the height of the image 
 *          returned by the camera.
 * @param bp The address of an integer, on successful return filled in with the bits per pixel.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Grabber_Get_Actual_Size(int *w,int *h,int *bp)
{
	DWORD pco_err;
	unsigned int wui,hui,bpui;
	
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Grabber_Get_Actual_Size",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(Command_Data.Grabber == NULL)
	{
		CCD_General_Error_Number = 1205;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Grabber_Get_Actual_Size:Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	if(w == NULL)
	{
		CCD_General_Error_Number = 1206;
		sprintf(CCD_General_Error_String,"PCO_Command_Grabber_Get_Actual_Size:w was NULL.");
		return FALSE;
	}
	if(h == NULL)
	{
		CCD_General_Error_Number = 1207;
		sprintf(CCD_General_Error_String,"PCO_Command_Grabber_Get_Actual_Size:h was NULL.");
		return FALSE;
	}
	if(bp == NULL)
	{
		CCD_General_Error_Number = 1208;
		sprintf(CCD_General_Error_String,"PCO_Command_Grabber_Get_Actual_Size:bp was NULL.");
		return FALSE;
	}
	pco_err = Command_Data.Grabber->Get_actual_size(&wui,&hui,&bpui);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1209;
		sprintf(CCD_General_Error_String,"PCO_Command_Grabber_Get_Actual_Size:"
			"Grabber->Get_actual_size failed(0x%x) (%s).",pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*w) = wui;
	(*h) = hui;
	(*bp) = bpui;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Grabber_Get_Actual_Size",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,"Finished and returned w = %d, h = %d, bp = %d.",
			       (*w),(*h),(*bp));
#endif
	return TRUE;
}
	
/**
 * Call the Grabber to acquire 1 frame from the camera, and place the data into the passed in image buffer.
 * @param image_buffer The address of some allocated memory to hold the read out image.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Grabber_Acquire_Image_Async_Wait(void *image_buffer)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Grabber_Acquire_Image_Async_Wait",LOG_VERBOSITY_VERBOSE,
			NULL,"Started.");
#endif
	if(Command_Data.Grabber == NULL)
	{
		CCD_General_Error_Number = 1148;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Grabber_Acquire_Image_Async_Wait:Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Grabber->Acquire_Image_Async_wait(image_buffer);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1149;
		sprintf(CCD_General_Error_String,"PCO_Command_Grabber_Acquire_Image_Async_Wait:"
			"Grabber Acquire_Image_Async_wait(%p) failed with PCO error code 0x%x (%s).",image_buffer,
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Grabber_Acquire_Image_Async_Wait",LOG_VERBOSITY_VERBOSE,
			NULL,"Finished.");
#endif
	return TRUE;	
}

/**
 * Call the Grabber to acquire 1 frame from the camera, and place the data into the passed in image buffer.
 * @param image_buffer The address of some allocated memory to hold the read out image.
 * @param timeout The time to wait for the image to be read out, before timing out, in milliseconds.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Grabber_Acquire_Image_Async_Wait_Timeout(void *image_buffer,int timeout_ms)
{
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Grabber_Acquire_Image_Async_Wait_Timeout",
			       LOG_VERBOSITY_VERBOSE,NULL,"Started with timeout %d ms.",timeout_ms);
#endif
	if(Command_Data.Grabber == NULL)
	{
		CCD_General_Error_Number = 1150;
		sprintf(CCD_General_Error_String,"PCO_Command_Grabber_Acquire_Image_Async_Wait_Timeout:"
			"Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Grabber->Acquire_Image_Async_wait(image_buffer,timeout_ms);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1151;
		sprintf(CCD_General_Error_String,"CCD_Command_Grabber_Acquire_Image_Async_Wait_Timeout:"
			"Grabber Acquire_Image_Async_wait(%p,%d) failed with PCO error code 0x%x (%s).",image_buffer,
			timeout_ms,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Grabber_Acquire_Image_Async_Wait_Timeout",
			LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif	
	return TRUE;
}

/**
 * Get the camera/sensor/psu temperatures from the camera.
 * @param valid_sensor_temp The address of an integer, on a successful return from this function this will contain
 *        TRUE if a valid sensor temperature was read, and FALSE if it was not read. This address can be NULL
 *        if the sensor temperature is not required.
 * @param sensor_temp The address of a double, on a successful return from this function this will contain
 *        the sensor temperature in degrees Centigrade if it was read successfully. This address can be NULL
 *        if the sensor temperature is not required.
 * @param camera_temp The address of an integer, on a successful return from this function this will contain
 *        the camera temperature in degrees Centigrade. This address can be NULL
 *        if the camera temperature is not required.
 * @param valid_psu_temp The address of an integer, on a successful return from this function this will contain
 *        TRUE if a valid PSU temperature was read, and FALSE if it was not read. This address can be NULL
 *        if the PSU temperature is not required.
 * @param psu_temp The address of an integer, on a successful return from this function this will contain
 *        the PSU temperature in degrees Centigrade. This address can be NULL
 *        if the PSU temperature is not required.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Temperature(int *valid_sensor_temp,double *sensor_temp,int *camera_temp,
				int *valid_psu_temp,int *psu_temp)
{
	DWORD pco_err;
	SHORT ccd_temp_s,cam_temp_s,psu_temp_s;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Temperature",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1152;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Temperature:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetTemperature(&ccd_temp_s,&cam_temp_s,&psu_temp_s);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1153;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Temperature:PCO_GetTemperature failed(0x%x) (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Temperature",LOG_VERBOSITY_VERY_VERBOSE,NULL,
			       "PCO_GetTemperature returns sensor temperature %d, "
			       "camera temperature %d, PSU temperature %d.",ccd_temp_s,cam_temp_s,psu_temp_s);
#endif
	/* PCO_GetTemperature returns:
	** A short for the CCD temperature in tenths of degree centigrade, 
	**          which is (SHORT)(-32768) when reading the temperature fails.
	** A short for the camera temperature in degrees centigrade.
	** A short for the power supply temperature in degrees centigrade, which id 0 when the sensor does not exist.
	*/
	if((valid_sensor_temp != NULL)&&(sensor_temp != NULL))
	{
		if(ccd_temp_s != (SHORT)(-32768))
		{
			(*valid_sensor_temp) = TRUE;
			(*sensor_temp) = ((double)ccd_temp_s)/10.0;
#ifdef PCO_DEBUG
			CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Temperature",
					       LOG_VERBOSITY_VERY_VERBOSE,NULL,"Valid Sensor temperature = %.3f C.",
					       (*sensor_temp));
#endif	
		}
		else
		{
			(*valid_sensor_temp) = FALSE;
			(*sensor_temp) = 0.0;
		}
	}
	if(camera_temp != NULL)
	{
		(*camera_temp) = (int)cam_temp_s;
#ifdef PCO_DEBUG
		CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Temperature",
				       LOG_VERBOSITY_VERY_VERBOSE,NULL,"Camera temperature = %d C.",(*camera_temp));
#endif	
	}
	if((valid_psu_temp != NULL)&&(psu_temp != NULL))
	{
		if(psu_temp_s != (SHORT)(0x000))
		{
			(*valid_psu_temp) = TRUE;
			(*psu_temp) = (int)psu_temp_s;
#ifdef PCO_DEBUG
			CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Temperature",
					       LOG_VERBOSITY_VERY_VERBOSE,NULL,"Valid PSU temperature = %d C.",
					       (*psu_temp));
#endif
		}
		else
		{
			(*valid_psu_temp) = FALSE;
			(*psu_temp) = 0;
		}
	}
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Temperature",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"Finished.");
#endif
	return TRUE;
}

/**
 * Get the number of analogue to digital convertors inside the camera, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param adc_count The address of an integer to store the numbers of analogue to digital convertors inside the camera.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Num_ADCs(int *adc_count)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Num_ADCs",LOG_VERBOSITY_INTERMEDIATE,
			NULL,"Started.");
#endif
	if(adc_count == NULL)
	{
		CCD_General_Error_Number = 1154;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Num_ADCs:adc_count was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1155;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Num_ADCs:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*adc_count) = Command_Data.Description.wNumADCsDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Num_ADCs",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "CCD_Command_Description_Get_Num_ADCs returned %d ADCs.",(*adc_count));
#endif
	return TRUE;
}

/**
 * Get the minimum exposure length of the camera, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param minimum_exposure_length_s The address of an double to store the minimum exposure length in seconds.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_GENERAL_ONE_SECOND_NS
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Exposure_Time_Min(double *minimum_exposure_length_s)
{
	DWORD min_expose_dw_ns;
	
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Exposure_Time_Min",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(minimum_exposure_length_s == NULL)
	{
		CCD_General_Error_Number = 1156;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Exposure_Time_Min:minimum_exposure_length_s was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1157;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Exposure_Time_Min:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	min_expose_dw_ns = Command_Data.Description.dwMinExposureDESC;
	/* The minimum exposure length in the description structure is in nanoseconds, convert to seconds */
	(*minimum_exposure_length_s) = ((double)min_expose_dw_ns)/((double)CCD_GENERAL_ONE_SECOND_NS);
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Exposure_Time_Min",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			    "PCO_Command_Description_Get_Exposure_Time_Min returned %.2f s minimum exposure length.",
			       (*minimum_exposure_length_s));
#endif
	return TRUE;
}

/**
 * Get the maximum exposure length of the camera, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param maximum_exposure_length_s The address of an double to store the maximum exposure length in seconds.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_GENERAL_ONE_SECOND_MS
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Exposure_Time_Max(double *maximum_exposure_length_s)
{
	DWORD max_expose_dw_ms;
	
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Exposure_Time_Max",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(maximum_exposure_length_s == NULL)
	{
		CCD_General_Error_Number = 1158;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Exposure_Time_Max:maximum_exposure_length_s was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1159;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Exposure_Time_Max:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	max_expose_dw_ms = Command_Data.Description.dwMaxExposureDESC;
	/* The maximum exposure length in the description structure is in milliseconds, convert to seconds */
	(*maximum_exposure_length_s) = ((double)max_expose_dw_ms)/((double)CCD_GENERAL_ONE_SECOND_MS);
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Exposure_Time_Max",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			     "PCO_Command_Description_Get_Exposure_Time_Max returned %.2f s maximum exposure length.",
			       (*maximum_exposure_length_s));
#endif
	return TRUE;
}

/**
 * Get the maximum horizontal (x) size of the camera sensor (in standard mode), as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param max_hor_size The address of an integer to store the maximum horizontal (x) size of the sensor, in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Max_Horizontal_Size(int *max_hor_size)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Max_Horizontal_Size",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(max_hor_size == NULL)
	{
		CCD_General_Error_Number = 1160;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Max_Horizontal_Size:max_hor_size was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1161;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Max_Horizontal_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*max_hor_size) = Command_Data.Description.wMaxHorzResStdDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Max_Horizontal_Size",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Description_Get_Max_Horizontal_Size returned %d pixels.",(*max_hor_size));
#endif
	return TRUE;
}

/**
 * Get the maximum vertical (y) size of the camera sensor (in standard mode), as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param max_ver_size The address of an integer to store the maximum vertical (y) size of the sensor, in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Max_Vertical_Size(int *max_ver_size)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Max_Vertical_Size",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(max_ver_size == NULL)
	{
		CCD_General_Error_Number = 1162;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Max_Vertical_Size:max_ver_size was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1163;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Max_Vertical_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*max_ver_size) = Command_Data.Description.wMaxVertResStdDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Max_Vertical_Size",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Description_Get_Max_Vertical_Size returned %d pixels.",(*max_ver_size));
#endif
	return TRUE;
}

/**
 * Get the pixel horizontal step size for the region of interest (ROI), as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * This is the increment step in pixels the corners of regions of interest are allowed to be specified in the 
 * horizontal direction.
 * @param step_size The address of an integer to store the horizontal step size 
 *        of the region of interest (ROI), in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_ROI_Horizontal_Step_Size(int *step_size)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_ROI_Horizontal_Step_Size",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(step_size == NULL)
	{
		CCD_General_Error_Number = 1201;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_ROI_Horizontal_Step_Size:step_size was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1202;
		sprintf(CCD_General_Error_String,
		   "PCO_Command_Description_Get_ROI_Horizontal_Step_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*step_size) = Command_Data.Description.wRoiHorStepsDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_ROI_Horizontal_Step_Size",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Description_Get_ROI_Horizontal_Step_Size returned %d pixel step size.",
			       (*step_size));
#endif
	return TRUE;
}

/**
 * Get the pixel vertical step size for the region of interest (ROI), as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * This is the increment step in pixels the corners of regions of interest are allowed to be specified in the 
 * vertical direction.
 * @param step_size The address of an integer to store the vertical step size 
 *        of the region of interest (ROI), in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_ROI_Vertical_Step_Size(int *step_size)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_ROI_Vertical_Step_Size",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(step_size == NULL)
	{
		CCD_General_Error_Number = 1203;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_ROI_Vertical_Step_Size:step_size was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1204;
		sprintf(CCD_General_Error_String,
		   "PCO_Command_Description_Get_ROI_Vertical_Step_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*step_size) = Command_Data.Description.wRoiVertStepsDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_ROI_Vertical_Step_Size",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Description_Get_ROI_Vertical_Step_Size returned %d pixel step size.",
			       (*step_size));
#endif
	return TRUE;
}

/**
 * Get the default cooling set-point of the camera sensor, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param temperature The address of an integer to store the default cooling setpoint, in degrees centigrade.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Default_Cooling_Setpoint(int *temperature)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Default_Cooling_Setpoint",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(temperature == NULL)
	{
		CCD_General_Error_Number = 1164;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Default_Cooling_Setpoint:temperature was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1165;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Default_Cooling_Setpoint:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*temperature) = Command_Data.Description.sDefaultCoolSetDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Default_Cooling_Setpoint",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Description_Get_Default_Cooling_Setpoint returned %d C.",(*temperature));
#endif
	return TRUE;
}

/**
 * Get the minimum cooling set-point of the camera sensor, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param temperature The address of an integer to store the minimum cooling setpoint, in degrees centigrade.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Min_Cooling_Setpoint(int *temperature)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Min_Cooling_Setpoint",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(temperature == NULL)
	{
		CCD_General_Error_Number = 1166;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Min_Cooling_Setpoint:temperature was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1167;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Min_Cooling_Setpoint:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*temperature) = Command_Data.Description.sMinCoolSetDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Min_Cooling_Setpoint",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Description_Get_Min_Cooling_Setpoint returned %d C.",(*temperature));
#endif
	return TRUE;
}

/**
 * Get the maximum cooling set-point of the camera sensor, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param temperature The address of an integer to store the maximum cooling setpoint, in degrees centigrade.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Max_Cooling_Setpoint(int *temperature)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Max_Cooling_Setpoint",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(temperature == NULL)
	{
		CCD_General_Error_Number = 1168;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Max_Cooling_Setpoint:temperature was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1169;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Max_Cooling_Setpoint:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*temperature) = Command_Data.Description.sMaxCoolSetDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Max_Cooling_Setpoint",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Description_Get_Max_Cooling_Setpoint returned %d C.",(*temperature));
#endif
	return TRUE;
}

/**
 * Get the type and sub-type of the camera sensor, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * The numbers are described in the MA_PCOSDK_V127.pdf SDK manual, Section 2.2.2.3 'Sensor Type Codes', P28.
 * @param sensor_type The address of an integer to store the sensor type code.
 * @param sensor_subtype The address of an integer to store the sensor sub-type code.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Description_Get_Sensor_Type(int *sensor_type,int *sensor_subtype)
{
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Description_Get_Sensor_Type",LOG_VERBOSITY_INTERMEDIATE,
			NULL,"Started.");
#endif
	if(sensor_type == NULL)
	{
		CCD_General_Error_Number = 1170;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Sensor_Type:sensor_type was NULL.");
		return FALSE;
	}
	if(sensor_subtype == NULL)
	{
		CCD_General_Error_Number = 1171;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Sensor_Type:sensor_subtype was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1172;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Description_Get_Sensor_Type:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*sensor_type) = Command_Data.Description.wSensorTypeDESC;
	(*sensor_subtype) = Command_Data.Description.wSensorSubTypeDESC;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Description_Get_Sensor_Type",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,"PCO_Command_Description_Get_Sensor_Type "
			       "returned sensor type code 0x%x and sensor sub-type code %d.",
			       (*sensor_type),(*sensor_subtype));
#endif
	return TRUE;
}

/**
 * Get the camera type and serial number of the currently connected camera.
 * @param camera_type The address of an integer to store the camera type number.
 * @param serial_number The address of an integer to store the serial number of the camera.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Camera_Type(int *camera_type,int *serial_number)
{
	DWORD pco_err;
	DWORD serial_number_dw;
	WORD camera_type_w;
	
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Camera_Type",LOG_VERBOSITY_INTERMEDIATE,
			NULL,"Started.");
#endif
	if(camera_type == NULL)
	{
		CCD_General_Error_Number = 1173;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Camera_Type:camera_type was NULL.");
		return FALSE;
	}
	if(serial_number == NULL)
	{
		CCD_General_Error_Number = 1174;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Camera_Type:serial_number was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1175;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Camera_Type:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetCameraType(&camera_type_w,&serial_number_dw);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1176;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Camera_Type:PCO_GetCameraType failed(0x%x) (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*camera_type) = camera_type_w;
	(*serial_number) = serial_number_dw;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Camera_Type",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "CCD_Command_Get_Camera_Type returned camera type = 0x%x, serial number = %d.",
			       (*camera_type),(*serial_number));
#endif
	return TRUE;
}

/**
 * Get the current 'region of interest', given the current binning settings. This is the area of the detector
 * to read out, in binned pixels.
 * @param start_x The address of an integer to store the first pixel in x on the detector to read out.
 * @param start_y The address of an integer to store the first pixel in y on the detector to read out.
 * @param end_x The address of an integer to store the last pixel in x on the detector to read out.
 * @param end_y The address of an integer to store the last pixel in y on the detector to read out.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_ROI(int *start_x,int *start_y,int *end_x,int *end_y)
{
	DWORD pco_err;
	WORD start_x_w,start_y_w,end_x_w,end_y_w;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_ROI",LOG_VERBOSITY_INTERMEDIATE,NULL,
			"Started.");
#endif
	if(start_x == NULL)
	{
		CCD_General_Error_Number = 1177;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_ROI:start_x was NULL.");
		return FALSE;
	}
	if(start_y == NULL)
	{
		CCD_General_Error_Number = 1178;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_ROI:start_y was NULL.");
		return FALSE;
	}
	if(end_x == NULL)
	{
		CCD_General_Error_Number = 1179;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_ROI:end_x was NULL.");
		return FALSE;
	}
	if(end_y == NULL)
	{
		CCD_General_Error_Number = 1180;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_ROI:end_y was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1181;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_ROI:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetROI(&start_x_w,&start_y_w,&end_x_w,&end_y_w);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1182;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_ROI:PCO_GetROI failed(0x%x) (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*start_x) = start_x_w;
	(*start_y) = start_y_w;
	(*end_x) = end_x_w;
	(*end_y) = end_y_w;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_ROI",LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Get_ROI returned start (%d,%d), end = (%d,%d).",
			       (*start_x),(*start_y),(*end_x),(*end_y));
#endif
	return TRUE;
}

/**
 * Get the actual size of the image that the camera will return, given the current binning and ROI settings.
 * @param image_width The address of an integer to store the width of the image, in pixels.
 * @param image_height The address of an integer to store height of the image, in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Actual_Size(int *image_width,int *image_height)
{
	DWORD pco_err;
	DWORD image_width_w,image_height_w;
	
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Actual_Size",LOG_VERBOSITY_INTERMEDIATE,
			NULL,"Started.");
#endif
	if(image_width == NULL)
	{
		CCD_General_Error_Number = 1183;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Actual_Size:image_width was NULL.");
		return FALSE;
	}
	if(image_height == NULL)
	{
		CCD_General_Error_Number = 1184;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Actual_Size:image_height was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1185;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Actual_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetActualSize(&image_width_w,&image_height_w);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1186;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Actual_Size:PCO_GetActualSize failed(0x%x) (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*image_width) = image_width_w;
	(*image_height) = image_height_w;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Actual_Size",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "PCO_Command_Get_Actual_Size returned width = %d pixels, height = %d pixels.",
			       (*image_width),(*image_height));
#endif
	return TRUE;
}

/**
 * Get the size of the image in bytes.
 * @param image_size The address of an integer to return the image size, in bytes.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */ 
int PCO_Command_Get_Image_Size_Bytes(int *image_size)
{
	int image_width,image_height;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Image_Size_Bytes",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(image_size == NULL)
	{
		CCD_General_Error_Number = 1187;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Image_Size_Bytes:image_size was NULL.");
		return FALSE;
	}
	/* get the binned image dimensions from the camera */
	if(!PCO_Command_Get_Actual_Size(&image_width,&image_height))
		return FALSE;
	/* I think pixels are unsigned shorts, typdefed to WORD in the PCO library (defs.h) */
	(*image_size) = image_width*image_height*sizeof(WORD);
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Image_Size_Bytes",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "Returned image size in bytes of %d.",(*image_size));
#endif
	return TRUE;
}

/**
 * Set how camera exposures are triggered
 * @param mode An enum of type PCO_COMMAND_TRIGGER_MODE. Used to select external or internal trigger modes.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #PCO_COMMAND_TRIGGER_MODE
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Trigger_Mode(enum PCO_COMMAND_TRIGGER_MODE *mode)
{
	DWORD pco_err;
	WORD mode_w;
	
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Trigger_Mode",LOG_VERBOSITY_VERBOSE,NULL,
			"Started.");
#endif
	if(mode == NULL)
	{
		CCD_General_Error_Number = 1188;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Trigger_Mode:mode was NULL.");
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1189;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Trigger_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetTriggerMode(&mode_w);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1190;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Trigger_Mode:"
			"Camera PCO_GetTriggerMode failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	switch(mode_w)
	{
		case 0x0: /* software/  auto */
			(*mode) = PCO_COMMAND_TRIGGER_MODE_INTERNAL;
			break;
		case 0x2: /* external exposure start & software trigger */
			(*mode) = PCO_COMMAND_TRIGGER_MODE_EXTERNAL;
			break;
		default:
			CCD_General_Error_Number = 1191;
			sprintf(CCD_General_Error_String,"PCO_Command_Get_Trigger_Mode:"
				"Camera PCO_GetTriggerMode returned unsupported trigger mode 0x%x.",mode_w);
			
			break;
	}
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Trigger_Mode",
			       LOG_VERBOSITY_VERBOSE,NULL,
			       "Finished and returned trigger mode %d.",(*mode));
#endif
	return TRUE;
}

/**
 * Get the currently set delay and exposure time.
 * @param delay_time The address of an integer, to be filled in with the current delay time, 
 *                    in units previously specified by PCO_Command_Set_Timebase.
 * @param exposure_time The address of an integer, to be filled in with the current exposure length, 
 *        in units previously specified by PCO_Command_Set_Timebase.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #PCO_Command_Set_Timebase
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Delay_Exposure_Time(int *delay_time,int *exposure_time)
{
	DWORD exp_time_dw,delay_time_dw;
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Delay_Exposure_Time",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"CCD_Command_Get_Delay_Exposure_Time: Started.");
#endif
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1192;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Delay_Exposure_Time:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetDelayExposure(&delay_time_dw,&exp_time_dw);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1193;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Delay_Exposure_Time:"
			"Camera PCO_GetDelayExposure failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	if(delay_time != NULL)
		(*delay_time) = delay_time_dw;
	if(exposure_time != NULL)
		(*exposure_time) = exp_time_dw;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Delay_Exposure_Time",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "Finished returning delay time %d, exposure time %d.",
			       delay_time_dw,exp_time_dw);
#endif
	return TRUE;
}

/**
 * Get the current cooling setpoint temperature.
 * @param temperature The address of an integer, to be filled in with the current setpoint temperature 
 *                    in degrees C.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_PCO_Get_Error_Text
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Cooling_Setpoint_Temperature(int *temperature)
{
	SHORT temperature_s;
	DWORD pco_err;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Cooling_Setpoint_Temperature",
			LOG_VERBOSITY_INTERMEDIATE,NULL,"Started.");
#endif
	if(temperature == NULL)
	{
		CCD_General_Error_Number = 1194;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Cooling_Setpoint_Temperature:temperature was NULL.");
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		CCD_General_Error_Number = 1195;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Cooling_Setpoint_Temperature:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetCoolingSetpointTemperature(&temperature_s);
	if(pco_err != PCO_NOERROR)
	{
		CCD_General_Error_Number = 1196;
		sprintf(CCD_General_Error_String,"PCO_Command_Get_Cooling_Setpoint_Temperature:"
			"Camera PCO_GetCoolingSetpointTemperature failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*temperature) = temperature_s;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Cooling_Setpoint_Temperature",
			       LOG_VERBOSITY_INTERMEDIATE,NULL,
			       "Finished returning setpoint temperature %d C.",temperature_s);
#endif
	return TRUE;
}

/**
 * Get the image number from the metadata encoded in the first few bytes of the image data.
 * The algorithm is copied from the example programs. 
 * The shift is zero for 64-bit linux machines with a PCO edge head.
 * @param image_buffer A pointer to the image data read out from the camera.
 * @param image_buffer_length The length of the image buffer.
 * @param image_number The address of an integer to store the decoded image number.
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Image_Number_From_Metadata(void *image_buffer,size_t image_buffer_length,int *image_number)
{
	unsigned short *b;
	int y,shift;
	int image_nr=0;

#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Image_Number_From_Metadata",
			LOG_VERBOSITY_VERBOSE,NULL,"Started.");
#endif
	if(image_buffer == NULL)
	{
		CCD_General_Error_Number = 1197;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Image_Number_From_Metadata:image_buffer was NULL.");
		return FALSE;
	}
	if(image_number == NULL)
	{
		CCD_General_Error_Number = 1198;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Image_Number_From_Metadata:image_number was NULL.");
		return FALSE;
	}
	shift = 0;
	b=(unsigned short *)(image_buffer);
	y=100*100*100;
	for(;y>0;y/=100)
	{
		*b>>=shift;
		image_nr += (((*b&0x00F0)>>4)*10 + (*b&0x000F))*y;
		b++;
	}
	(*image_number) = image_nr;
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Image_Number_From_Metadata",
			       LOG_VERBOSITY_VERBOSE,NULL,"Returned image number %d.",(*image_number));
#endif
	return TRUE;
}

/**
 * Routine to extract the timestamp from the read out image data.
 * @param image_buffer A pointer to the image data.
 * @param image_buffer_length The length of the image buffer in bytes.
 * @param camera_timestamp The address of a timespec structure. On a successful return this will be filled in
 *        with the extracted timestamp.
 * @see #Command_BCD_To_Decimal
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_Number
 * @see ../../cdocs/ccd_general.html#CCD_General_Error_String
 * @see ../../cdocs/ccd_general.html#CCD_General_Log
 * @see ../../cdocs/ccd_general.html#CCD_General_Log_Format
 */
int PCO_Command_Get_Timestamp_From_Metadata(void *image_buffer,size_t image_buffer_length,
					    struct timespec *camera_timestamp)
{
	struct tm timestamp_tm;
	WORD *picbuf = NULL;
	int century,year,month,day,hour,mins,secs,csecs,ccsec;
	
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Timestamp_From_Metadata",
			LOG_VERBOSITY_VERBOSE,NULL,"Started.");
#endif	
	if(image_buffer == NULL)
	{
		CCD_General_Error_Number = 1199;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Timestamp_From_Metadata:image_buffer was NULL.");
		return FALSE;
	}
	if(camera_timestamp == NULL)
	{
		CCD_General_Error_Number = 1200;
		sprintf(CCD_General_Error_String,
			"PCO_Command_Get_Timestamp_From_Metadata:camera_timestamp was NULL.");
		return FALSE;
	}
	picbuf = (WORD*)image_buffer;
	century = Command_BCD_To_Decimal(picbuf[4]);
	year = Command_BCD_To_Decimal(picbuf[5]);
	month = Command_BCD_To_Decimal(picbuf[6]);
	day = Command_BCD_To_Decimal(picbuf[7]);
	hour = Command_BCD_To_Decimal(picbuf[8]);
	mins = Command_BCD_To_Decimal(picbuf[9]);
	secs = Command_BCD_To_Decimal(picbuf[10]);
	csecs = Command_BCD_To_Decimal(picbuf[11]); /* tenths and hundredths of a second */
	ccsec = Command_BCD_To_Decimal(picbuf[12]); /* thousandths and ten thousandths of a second */
#ifdef PCO_DEBUG
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Timestamp_From_Metadata",
			       LOG_VERBOSITY_VERY_VERBOSE,NULL,
			      "PCO_Command_Get_Timestamp_From_Metadata: century = %d, year = %d, month = %d, day = %d.",
			       century,year,month,day);
	CCD_General_Log_Format("ccd","pco_command.cpp","PCO_Command_Get_Timestamp_From_Metadata",
			       LOG_VERBOSITY_VERY_VERBOSE,NULL,
			      "PCO_Command_Get_Timestamp_From_Metadata: hour = %d, minutes = %d, seconds = %d, tenths/hundredths = %d, thousandths and ten thousandths = %d.",
			       hour,mins,secs,csecs,ccsec);
#endif
	/* setup timestamp_tm */
	timestamp_tm.tm_sec = secs;
	timestamp_tm.tm_min = mins;
	timestamp_tm.tm_hour = hour;
	timestamp_tm.tm_mday = day;
	timestamp_tm.tm_mon = month-1; /* tm_mon 0..11, month 1..12 */
	timestamp_tm.tm_year = year; /* tm_year is year - 1900 */
	if(century == 20)
		timestamp_tm.tm_year += 100; /* tm_year is year - 1900 */
	/* ignored by mktime
	timestamp_tm.tm_wday = ;
	timestamp_tm.tm_yday = ;
	*/
	timestamp_tm.tm_isdst = 0; /* no daylight saving time */
	/* convert timestamp_tm to a time_t (seconds since the epoch) and store in camera_timestamp.tv_sec */
	(*camera_timestamp).tv_sec = mktime(&timestamp_tm);
	(*camera_timestamp).tv_nsec = (csecs*10000000)+(ccsec*100000);
#ifdef PCO_DEBUG
	CCD_General_Log("ccd","pco_command.cpp","PCO_Command_Get_Timestamp_From_Metadata",
			LOG_VERBOSITY_VERBOSE,NULL,"Finished.");
#endif
	return TRUE;
}
		
/* =======================================
**  internal functions 
** ======================================= */
/**
 * This function is a wrapper to the PCO_GetErrorText routine imported from the PCO_errt_w.h.
 * This allows us to produce a descriptive string for the specified PCO error code.
 * @param pco_err The PCO error code to provide a descriptive string for.
 * @return A pointer to a string containing the descriptive string for the PCO error code. The
 *         string pointer to is always Command_PCO_Error_String.
 * @see #CCD_GENERAL_ERROR_STRING_LENGTH
 * @see #Command_PCO_Error_String
 */
static char *Command_PCO_Get_Error_Text(DWORD pco_err)
{
	PCO_GetErrorText(pco_err,Command_PCO_Error_String,CCD_GENERAL_ERROR_STRING_LENGTH);
	return Command_PCO_Error_String;
}

/**
 * Routine to convert the BCD (binary coded decimal) number to a normal integer.
 * @param x An unisgned char containing the BCD number (0..100). This is normally passed in a WORD, and we take
 *        the lower byte which contains the encoded number.
 * @return The decoded integer (0..100).
 */
static int Command_BCD_To_Decimal(unsigned char x)
{
    return x - 6 * (x >> 4);
}
